---
title: 管理状态 | Microsoft Docs
description: 介绍 Bot Builder SDK 中状态的工作原理。
keywords: 状态, 机器人状态, 聊天状态, 用户状态
author: ivorb
ms.author: v-ivorb
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 11/15/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 366a985e839c8a79fcd8794c139e2e8130a05335
ms.sourcegitcommit: 6cb37f43947273a58b2b7624579852b72b0e13ea
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/22/2018
ms.locfileid: "52288867"
---
# <a name="managing-state"></a>管理状态

机器人中的状态遵循与新式 Web 应用程序相同的模式，Bot Framework SDK 提供一些抽象用于简化状态管理。

与 Web 应用一样，机器人在本质上也是无状态的；机器人的不同实例可以处理任意给定的聊天轮次。 某些机器人倾向于采用这种简单设计 - 要么不提供附加的信息就使机器人能够正常运行，要么保证在传入的消息中提供所需的信息。 对于其他一些机器人而言，必须提供状态（例如，我们目前在聊天中所处的位置，或者以前收到的有关用户的数据）才能让机器人提供有用的聊天信息。

**为何需要状态？**

维护状态可以记住有关用户或聊天的某些信息，使机器人能够进行更有意义的聊天。 例如，如果你以前与某个用户交谈过，则可以事先保存有关该用户的信息，这样，下次就不再需要请求提供这些信息。 状态还能以长于当前轮次的时间保留数据，使机器人能够在整个多轮次聊天过程中保留信息。

由于本文所述的状态与机器人相关，在使用状态时，需要创建几个层：存储层、状态管理和状态属性访问器。

## <a name="storage-layer"></a>存储层

从后端开始，实际存储状态信息的位置是存储层。 可将存储层视为物理存储，例如内存中服务器、Azure 服务器或第三方服务器。

Bot Framework SDK 提供存储层的实现（例如内存中存储）用于本地测试，并提供 Azure 存储或 CosmosDB 的实现用于测试和部署到云。

## <a name="state-management"></a>状态管理

状态管理可以自动在基础存储层中读取和写入机器人的状态。 状态以状态属性的形式存储。状态属性实际上是机器人可以通过状态管理对象读取和写入的键值对（不管具体的基础实现是什么）。 这些状态属性定义信息的存储方式。 例如，当你检索某个定义为特定类或对象的属性时，便知道数据的建构方式。

这些状态属性集结到有范围的“桶”中，这些桶不过是一些帮助组织这些属性的集合。 SDK 包含其中的三个“桶”：

- 用户状态
- 聊天状态
- 私人聊天状态

所有这些桶都是 *bot state* 类的子类，可以派生该类来定义其他类型的桶。

只能根据具体的桶，在特定的可见范围内使用这些预定义的桶：

- 不管聊天内容如何，机器人在该通道中与该用户展开的任何聊天轮次都会提供用户状态
- 不管用户是谁（例如群组聊天），特定聊天中的任何轮次都会提供聊天状态
- 私人聊天状态的范围限定为特定聊天和特定用户

用于其中每个预定义桶的键特定于用户和/或聊天。 设置状态属性的值时，将在内部使用轮次上下文中包含的信息定义键，以确保将每个用户或聊天置于适当的桶和属性中。 具体而言，将按如下所述定义键：

- 用户状态使用通道 ID 和源 ID 创建键。 例如 _{Activity.ChannelId}/users/{Activity.From.Id}#YourPropertyName_
- 聊天状态使用通道 ID 和聊天 ID 创建键。 例如 _{Activity.ChannelId}/conversations/{Activity.Conversation.Id}#YourPropertyName_
- 私人聊天状态使用通道 ID、源 ID 和聊天 ID 创建键。 例如 _{Activity.ChannelId}/conversations/{Activity.Conversation.Id}/users/{Activity.From.Id}#YourPropertyName_

有关使用这些预定义桶的详细信息，请参阅[状态操作方法文章](bot-builder-howto-v4-state.md)。

## <a name="state-property-accessors"></a>状态属性访问器

状态属性访问器用于实际读取或写入某个状态属性，并提供 *get*、*set* 和 *delete* 方法用于从轮次内部访问状态属性。 若要创建访问器，必须提供属性名称（通常是在初始化机器人时提供）。 然后，可以使用该访问器来获取和处理机器人状态的该属性。

访问器允许 SDK 从基础存储获取状态并更新机器人的状态缓存。 状态缓存是机器人维护的本地缓存，用于存储状态对象，并允许在不访问基础存储的情况下执行读取和写入操作。 如果状态尚未进入缓存，则调用访问器的 *get* 方法可以检索状态并将其放入缓存。 检索后，可以像处理本地变量一样处理状态属性。

访问器的 *delete* 方法会从缓存和基础存储中删除属性。

> [!IMPORTANT]
> 首次调用访问器的 *get* 方法时，必须提供一个工厂方法用于创建对象（如果状态中尚不存在该对象）。 如果未指定工厂方法，则会出现异常。 在[状态操作方法文章](bot-builder-howto-v4-state.md)中可以找到有关如何使用工厂方法的详细信息。

若要保存对你从访问器获取的状态属性所做的任何更改，必须更新状态缓存中的属性。 为此，可以调用访问器的 *set* 方法，以便设置缓存中属性的值；如果以后需要在该轮次中读取或更新该属性，也可以使用此方法。 若要将该数据实际保存到基础存储（从而使该数据在当前轮次结束后可供使用），必须[保存状态](#saving-state)。

### <a name="how-the-state-property-accessor-methods-work"></a>状态属性访问器方法的工作原理

访问器方法是机器人与状态交互的主要方法。 下面介绍了每个方法的工作原理以及基础层的交互方式：

- 访问器的 *get*
    - 访问器从状态缓存请求属性
    - 如果该属性在缓存中，则返回它。 否则，从状态管理对象获取该属性。
        - 如果该属性尚未保存到状态中，则使用访问器 *get* 调用中提供的工厂方法。
- 访问器的 *set*
    - 使用新属性值更新状态缓存。
- 状态管理对象的 *save changes*
    - 检查对状态缓存中属性所做的更改。
    - 将属性写入存储。

## <a name="saving-state"></a>保存状态

调用访问器的 set 方法来记录更新的状态时，该状态属性尚未保存到持久性存储，而只是保存到了机器人的状态缓存。 若要将状态缓存的任何更改保存到持久性状态，必须调用状态管理对象的 *save changes* 方法。可以针对上述机器人状态类的实现（例如用户状态或聊天状态）使用此方法。

针对某个状态管理对象（例如上述桶）调用 save changes 方法会保存当时为该桶（而不是机器人状态中保存的其他任何桶）设置的状态缓存中的所有属性。

> [!TIP]
> 机器人状态实现“最后一次写入优先”行为，即最后一次写入会改写上一次写入的状态。 此行可能适合许多应用场合，但也会带来负面影响，尤其是横向扩展方案中需要提供某种并发度或控制延迟时。

如果某些定制中间件在轮次处理程序完成后可能需要更新状态，请考虑[在中间件中处理状态](bot-builder-concept-middleware.md#handling-state-in-middleware)。

## <a name="additional-resources"></a>其他资源

- [对话状态](bot-builder-concept-dialog.md#dialog-state)
- [直接写入到存储](bot-builder-howto-v4-storage.md)
- [保存聊天和用户数据](bot-builder-howto-v4-state.md)