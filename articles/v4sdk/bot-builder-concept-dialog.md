---
title: Bot Framework SDK 中的对话 | Microsoft Docs
description: 介绍了什么是对话，以及如何在 Bot Framework SDK 中使用对话。
keywords: 聊天流, 提示, 对话状态, 识别意向, 单轮次, 多轮次, 机器人聊天, 对话, 提示, 瀑布, 对话集
author: johnataylor
ms.author: johtaylo
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 04/18/2019
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 36ccbb796c2cd014118d4ae1f426acd44aabed76
ms.sourcegitcommit: aea57820b8a137047d59491b45320cf268043861
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/22/2019
ms.locfileid: "59904890"
---
# <a name="dialogs-library"></a>对话框库

[!INCLUDE [applies-to-v4](../includes/applies-to.md)]

“对话”是 SDK 中的一个核心概念，它提供一种有用的方式来管理与用户之间的聊天。 对话是机器人中的结构，其行为类似于机器人程序中的函数；每个对话按特定的顺序执行特定的任务。 可以指定各个对话的顺序来引导聊天，然后以不同的方式调用这些对话 - 有时是为了响应某个用户，有时是为了响应某个外部信号，或者来自其他对话的信号。

对话库提供一些内置功能（例如“提示”和“瀑布对话”）来简化机器人聊天的管理。 [提示](#prompts)用于请求不同类型的信息，例如文本、数字或日期。 [瀑布对话](#waterfall-dialogs)可将多个步骤合并在一个序列中，使机器人能够轻松遵循该预定义的序列，并将信息传递到下一个步骤。

<!-- When we have samples for building your own, add links and one liner about them -->

## <a name="dialogs-and-their-pieces"></a>对话及其片段

对话库包含一些附加的片段，使对话变得更加有用。 除了下面所述的不同[对话类型](#dialog-types)以外，该库还包含“对话集”、“对话上下文”和“对话结果”的概念。

简单地说，对话集是对话的集合。 这可能包括提示、瀑布对话或[组件对话](#component-dialog)等对象。 其中的每个对象都是对话的实现，并将添加到对话集并带有特定的字符串 ID。 当机器人想要启动对话集中的特定对话或提示时，它会使用该字符串 ID 来指定要使用的对话。

对话上下文包含对话相关的信息，用于从机器人轮次处理程序内部来与对话集交互。 对话上下文包含当前轮次上下文、父对话和[对话状态](#dialog-state)。对话状态提供一种方法用于在对话中保留信息。 借助对话上下文可以使用对话的字符串 ID 来启动该对话，或继续当前的对话（例如，包含多个步骤的瀑布对话）。

对话结束时，可以返回一个对话结果，其中包含对话生成的某些信息。 返回此结果的目的是让调用方法了解对话中发生的情况，并根据需要将信息保存到某个持久位置。

## <a name="dialog-state"></a>对话框状态

对话是实现多轮次聊天的一种方法，因此，在依赖于跨多个轮次的持久化状态的 SDK 中，对话可以充当特征的示例。 如果对话中没有状态，则机器人就不知道它在对话集中所处的位置，也不知道它已收集的信息。

通常，基于对话的机器人在其机器人实现中以成员变量的形式保存对话集集合。 该对话集是使用称作“访问器”（可用于访问持久性状态）的对象句柄创建的。 有关机器人中的状态的背景信息，请参阅[管理状态](bot-builder-concept-state.md)。

在机器人的轮次处理程序中，机器人通过针对对话集调用 *create context*（这会返回对话上下文）来初始化对话子系统。 该对话上下文包含对话所需的信息。

创建对话上下文需要状态，可以使用创建对话集时提供的访问器来访问状态。 对话集可以使用访问器获得相应的对话状态。 在[保存聊天和用户数据](bot-builder-howto-v4-state.md)中可以找到有关状态访问器的详细信息。

## <a name="dialog-types"></a>对话类型

对话分为几个不同的类型：提示、瀑布对话和组件对话，如以下类层次结构中所示。

![对话框类](media/bot-builder-dialog-classes.png)

### <a name="prompts"></a>提示

使用对话库中的提示可以轻松请求用户提供信息，以及评估其响应。 例如，对于数字提示，可以指定问题或所要请求的信息，提示会自动检查它是否收到了有效的数字响应。 如果已收到，则聊天可以继续；否则，会重新提示用户提供有效的回答。

在幕后，提示是由两个步骤组成的对话。 首先，提示会请求输入；其次，它会返回有效值，或者使用重新提示从头开始。

调用提示时，为提示指定 *prompt options*，可在其中指定要提示的文本、验证失败时的重试提示，以及回答提示所用的选项。

此外，在创建提示时可为提示添加某种自定义验证。 例如，假设我们想要使用数字提示获取聚会规模，但该聚会规模必须大于 2 且小于 12。 提示首先会检查它是否收到了有效的数字，如果收到，则运行自定义验证。 如果自定义验证失败，则它会按如上所述重新提示用户。

提示完成时，会显式返回所请求的结果值。 返回该值后，我们可以确定结果既通过了内置的提示验证，也通过了可能提供的任何其他自定义验证。

有关使用各种提示的示例，请查看如何[使用对话库收集用户输入](bot-builder-prompts.md)。

#### <a name="prompt-types"></a>提示类型

在幕后，提示是由两个步骤组成的对话。 首先，提示会请求输入；其次，它会返回有效值，或者使用重新提示从头开始。 对话库提供多种基本提示，每个提示用于收集不同类型的响应。 基本提示可以解释解释自然语言输入，例如，“ten”或“a dozen”表示数字，“tomorrow”或“Friday at 10am”表示日期时间。

| Prompt | 说明 | 返回值 |
|:----|:----|:----|
| 附件提示 | 请求提供一个或多个附件，例如文档或图像。 | 附件对象的集合。 |
| 选项提示 | 请求从一组选项中选择一个选项。 | 找到的选项对象。 |
| 确认提示 | 请求确认。 | 布尔值。 |
| 日期时间提示 | 请求提供日期时间。 | 日期时间解析对象的集合。 |
| 数字提示 | 要求提供数字。 | 数字值。 |
| 文本提示 | 请求提供常规文本输入。 | 一个字符串。 |

若要提示用户输入，请使用某个内置类（例如“文本提示”）定义一个提示，并将其添加到对话集。 提示具有固定的 ID，该 ID 必须在对话集中唯一。 可为每个提示创建自定义的验证程序。对于某些提示，可以指定默认区域设置。 

#### <a name="prompt-locale"></a>提示区域设置

使用区域设置来确定**选项**、**确认**、**日期时间**和**数字**提示的特定于语言的行为。 对于用户提供的任何给定输入，如果通道在用户的消息中提供了 _locale_ 属性，则使用该属性。 否则，如果设置了提示的默认区域设置（通过在调用提示的构造函数时提供，或者在以后进行设置），则会使用该区域设置。 如果未提供上述任一属性，则使用“英语”("en-us") 作为区域设置。 注意：区域设置是由 2、3 或 4 个字符组成的 ISO 639 代码，代表某种语言或语言系列。

### <a name="waterfall-dialogs"></a>瀑布对话

瀑布对话是对话的特定实现，通常用于从用户那里收集信息或指导用户完成一系列任务。 聊天的每个步骤实现为采用瀑布步骤上下文 (`step`) 参数的异步函数。 在每个步骤中，机器人会[提示用户输入](bot-builder-prompts.md)（或开始子对话，但这通常是提示），等待响应，然后将结果传递到下一步骤。 第一个函数的结果作为参数传递给下一个函数，依此类推。

下图显示一系列瀑布步骤以及发生的堆栈操作。 下面的[使用对话](#using-dialogs)部分详细介绍了对话堆栈的用法。

![对话框概念](media/bot-builder-dialog-concept.png)

在瀑布步骤中，瀑布对话的上下文存储在它的瀑布步骤上下文中。 这类似于对话上下文，因为它也提供对当前轮次上下文和状态的访问。 使用瀑布步骤上下文对象从瀑布步骤内通过对话集进行互动。

可以在对话的瀑布步骤内部，或者通过机器人的轮次处理程序来处理对话的返回值，不过，通常需要通过机器人的轮次逻辑来检查对话轮次结果的状态。
在瀑布步骤中，对话框在瀑布步骤上下文的 _result_ 属性中提供返回值。

#### <a name="waterfall-step-context-properties"></a>瀑布步骤上下文属性

瀑布步骤上下文包含以下属性：

* *选项*：包含对话的输入信息。
* *值*：包含可添加到上下文，然后传递到后续步骤的信息。
* *结果*：包含上一步骤的结果。

此外，*next* 方法会转到同一轮次中瀑布对话的下一个步骤，使机器人能够视需要跳过特定的步骤。

### <a name="component-dialog"></a>组件对话框

有时，我们想要编写可在不同的方案中重复使用的对话，例如，编辑地址对话来请求用户提供街道、城市和邮政编码的值。

组件对话提供一种策略用于创建独立的对话来处理特定的方案，将大型对话集分解成更易于管理的片段。 其中的每个片段有自身的对话集，可避免与包含该片段的对话集发生名称冲突。 有关组件对话的详细信息，请参阅[组件对话操作指南](bot-builder-compositcontrol.md)。

## <a name="using-dialogs"></a>使用对话

可以使用对话上下文来开始、继续、替换或结束对话。 还可以取消对话堆栈中的所有对话。

可将对话视为编程堆栈（称为“对话堆栈”），可将轮次处理程序视为对话引导者，以及堆栈为空时的回退机制。 该堆栈最顶端的项被视为“活动对话”，对话上下文会将所有输入定向到活动对话。

开始某个对话时，会将它推送到堆栈，现在，该对话即为活动对话。 该对话在结束之前将一直保留为活动对话；结束后，该对话将被 [replace dialog](#repeating-a-dialog) 方法删除，或者，轮次处理程序或活动对话本身会将另一个对话被推送到堆栈，然后，这另一个对话将成为活动对话。 该新对话框结束后，将从堆栈中弹出，而下一个对话框将成为活动对话框。 这样就可以实现下面所述的分支和循环。

### <a name="create-the-dialog-context"></a>创建对话上下文

若要创建对话上下文，请调用对话集的 *create context* 方法。 create context 获取对话集的对话框状态属性，并使用该属性创建对话上下文。 然后，使用对话上下文来启动、继续或控制集中的对话。

对话集要求使用状态属性访问器访问对话状态。 该访问器的创建和使用方式与其他状态访问器相同，但它会根据聊天状态创建为自身的属性。 有关管理状态的详细信息，请参阅[管理状态](bot-builder-concept-state.md)主题；有关对话状态的用法，请参阅[有序聊天流](bot-builder-dialog-manage-conversation-flow.md)操作指南。

### <a name="to-start-a-dialog"></a>启动对话

若要启动某个对话，请将要启动的对话 ID 传入对话上下文的 *begin dialog*、*prompt* 或 *replace dialog* 方法。

* begin dialog 方法会将对话框推送到堆栈顶部。
* replace dialog 方法会将当前对话框从堆栈中弹出，并将用于替换的对话框推送到堆栈上。 被替换的对话框会被系统取消，该实例包含的任何信息都会被释放。

使用 _options_ 参数将信息传递到对话框的新实例。
传递到新对话框中的选项可以在对话框的任何步骤中通过步骤上下文的 *options* 属性进行访问。
请参阅[使用分支和循环创建高级聊天流](bot-builder-dialog-manage-complex-conversation-flow.md)，了解操作方法示例代码。

### <a name="to-continue-a-dialog"></a>继续对话

若要继续对话，请调用 *continue dialog* 方法。 continue 方法始终继续堆栈最顶端的对话（活动对话，如果有）。 如果继续的对话结束，控制权将传递给同一轮次中继续的父上下文。

使用步骤上下文的 *values* 属性保留轮次之间的状态。
在上一轮次添加到此集合的任何值都可以在后续轮次中使用。
请参阅[使用分支和循环创建高级聊天流](bot-builder-dialog-manage-complex-conversation-flow.md)，了解操作方法示例代码。

### <a name="to-end-a-dialog"></a>结束对话：

*end dialog* 方法通过从堆栈中弹出对话并将可选结果返回到父上下文（例如，调用该方法的对话，或机器人的轮次处理程序）的方式来结束对话。 往往是从对话内部调用此方法，以结束该对话自身的当前实例。

可以从具有对话上下文的任何位置调用 end dialog 方法，但对于机器人而言，该方法似乎是从当前活动对话调用的。

> [!TIP]
> 最佳做法是在对话结束时显式调用 *end dialog* 方法。

### <a name="to-clear-all-dialogs"></a>清除所有对话

若要使所有对话从堆栈中弹出，可以调用对话上下文的 *cancel all dialogs* 方法来清除对话堆栈。

### <a name="repeating-a-dialog"></a>重复某个对话框

可以使用对话框自身来替换对话框，创建一个循环。
这是处理[复杂交互](~/v4sdk/bot-builder-dialog-manage-complex-conversation-flow.md)和管理菜单的极佳方法。

> [!NOTE]
> 如需保存当前对话的内部状态，则需要在调用 *replace dialog* 方法时将信息传递给对话的新实例，然后适当地初始化该对话。

### <a name="branch-a-conversation"></a>将聊天分支

对话上下文维护对话堆栈，对于堆栈中的每个对话，将跟踪下一个步骤是什么。 它的 *begin dialog* 方法创建子级，并将对话推送到堆栈的顶层；它的 *end dialog* 方法从堆栈中弹出顶层对话。 通常，*end dialog* 是从要结束的对话调用的。

一个对话框可以调用对话框上下文的 *begin dialog* 方法并提供新对话框的 ID，以便启动同一对话框集中的新对话框，随后使新对话框成为当前的活动对话框。 原始对话框仍保留在堆栈中，但对对话框上下文的 *continue dialog* 方法的调用只会发送到位于堆栈顶层的对话框，即“活动对话框”。 将某个对话框从堆栈中弹出后，对话框上下文会在堆栈中弹出原始对话框的位置处继续执行瀑布框的下一步。

因此，可以在聊天流中创建分支，方法是在一个对话框中包含一个选择步骤（该步骤可按条件从一组可用对话框中选出一个要启动的对话框）。

## <a name="next-steps"></a>后续步骤

> [!div class="nextstepaction"]
> [使用对话库收集用户输入](bot-builder-prompts.md)
