---
title: Bot Builder SDK 中的对话框 | Microsoft Docs
description: 介绍什么是对话框，以及如何在 Bot Builder SDK 中使用对话框。
keywords: 聊天流, 提示, 对话状态, 识别意向, 单轮次, 多轮次, 机器人聊天, 对话, 提示, 瀑布, 对话集
author: johnataylor
ms.author: johtaylo
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 11/22/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 964d4a0344df595630f5b38fa32b3cc3a526ed5c
ms.sourcegitcommit: bbfb171f515c50a3c8bba5ca898daf25cf764378
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/23/2018
ms.locfileid: "52293589"
---
# <a name="dialogs-library"></a>对话框库

[!INCLUDE [pre-release-label](../includes/pre-release-label.md)]

通过“对话框”概念来管理聊天是 SDK 的核心。 对话框对象处理入站活动并生成出站响应。 机器人的业务逻辑在对话框类中直接或间接运行。

对话框实例在运行时以堆栈的形式排列。 堆栈顶部的对话框称为 ActiveDialog。 当前的活动对话框处理入站活动。 在每轮聊天（没有时限，可能持续数天以上）之间，会保留堆栈。 

## <a name="dialog-lifecycle"></a>对话框生命周期

对话框实现三个主要函数：
- BeginDialog
- ContinueDialog
- ResumeDialog

在运行时，可以配合使用 Dialogs 和 DialogContext 类来选择适用于处理活动的对话框。 DialogContext 类会将保留的对话框堆栈、入站活动和 DialogSet 类绑定在一起。 DialogSet 包含机器人可以调用的对话框。

DialogContext 的接口反映对话框的开始和继续这样的基础概念。 应用程序的常规模式始终是首先调用 ContinueDialog。 如果没有堆栈，因此也没有 ActiveDialog，应用程序就会在 DialogContext 上调用 BeginDialog，启动所选的对话框。 这会导致相应的对话框条目从 DialogSet 推送到堆栈（严格说来，添加到堆栈中的是对话框的 ID），然后会在特定的对话框对象上委托对 BeginDialog 的调用。 如果已经有 ActiveDialog，则会在处理过程中直接委托对该对话框的 ContinueDialog 的调用，为该对话框提供任何关联的保留属性。

请注意，**对话框的 BeginDialog** 是初始化代码，采用初始化属性（在代码中称为“options”）；**对话框的 ContinueDialog** 是运行起来就可以在暂留后的活动到达后继续执行的代码。 例如，假设一个对话框询问用户一个问题，则该问题会在 BeginDialog 中提出，回答会在 ContinueDialog 中提供。

若要支持对话框嵌套（对话框包含子对话框），可以使用另一类型的继续，即恢复。 当子对话框完成后，DialogContext 会在父对话框上调用 ResumeDialog 方法。

提示和瀑布框都是 SDK 提供的对话框的具体示例。 许多方案是通过将这些抽象的东西组合在一起来生成的，但实际上，执行的逻辑自始至终都没有变，这就是此处介绍的继续和恢复模式。 

Bot Builder SDK 中的“对话框”库包含内置功能（例如提示、瀑布对话框、组件对话框），有助于管理机器人的聊天。 可以使用提示来要求用户提供不同类型的信息，使用瀑布框将多个步骤组合到一个序列中，使用组件对话框将对话框逻辑打包到单独的类中，然后将这些类集成到其他机器人中。
## <a name="waterfall-dialogs-and-prompts"></a>瀑布对话框和提示

**对话框**库提供一组提示类型，这些类型可以用来收集不同类型的用户输入。 例如，要求用户输入文本，可以使用 **TextPrompt**；要求用户输入数字，可以使用 **NumberPrompt**；要求用户输入日期和时间，可以使用 **DateTimePrompt**。 提示是特定类型的对话框。 若要使用瀑布对话框中的提示，请将瀑布对话框和提示都添加到同一对话框集。 

考虑到提示-响应交互的性质，实现一个提示至少需要在瀑布对话框中执行两个步骤 - 一个步骤用于发送提示，另一个步骤用于捕获和处理响应。  如果有其他提示，有时可以使用单个函数先处理用户的响应，然后启动下一提示，将这些操作组合在一起。

`WaterfallDialog` 是特定的对话框实现，用于从用户那里收集信息或指导用户完成一系列任务。 任务作为一组函数来实现，第一个函数的结果作为参数传递到下一个函数，依此类推。 每个函数通常表示整个过程中的一步。 在每个步骤中，机器人会提示用户输入，等待响应，然后将结果传递到下一步。 

提示和瀑布框均属对话框，如以下类层次结构所示。 

![对话框类](media/bot-builder-dialog-classes.png)

瀑布对话框由一系列瀑布步骤组成。 每个步骤都是一个异步委托，该委托采用瀑布步骤上下文 (`step`) 参数。 此模式是：瀑布步骤中的最后一项操作不是启动子对话框（通常为提示），就是终止瀑布框本身。 下图显示一系列瀑布步骤以及发生的堆栈操作。

![对话框概念](media/bot-builder-dialog-concept.png)

可以在对话框的瀑布步骤中处理对话框的返回值，也可以通过机器人的轮次处理程序来处理。
在瀑布步骤中，对话框在瀑布步骤上下文的 _result_ 属性中提供返回值。
通常只需通过机器人的轮次逻辑检查对话框轮次结果的状态。

## <a name="about-prompt-types"></a>关于提示类型

在幕后，提示是由两个步骤组成的对话。 首先，提示会请求输入；其次，它会返回有效值，或者使用重新提示从头开始。 对话库提供多种基本提示，每个提示用于收集不同类型的响应。 基本提示可以解释解释自然语言输入，例如，“ten”或“a dozen”表示数字，“tomorrow”或“Friday at 10am”表示日期时间。

| Prompt | Description | 返回值 |
|:----|:----|:----|
| 附件提示 | 请求提供一个或多个附件，例如文档或图像。 | 附件对象的集合。 |
| 选项提示 | 请求从一组选项中选择一个选项。 | 找到的选项对象。 |
| 确认提示 | 请求确认。 | 布尔值。 |
| 日期时间提示 | 请求提供日期时间。 | 日期时间解析对象的集合。 |
| 数字提示 | 要求提供数字。 | 数字值。 |
| 文本提示 | 请求提供常规文本输入。 | 一个字符串。 |

若要提示用户输入，请使用某个内置类（例如“文本提示”）定义一个提示，并将其添加到对话集。 提示具有固定的 ID，该 ID 必须在对话集中唯一。 可为每个提示创建自定义的验证程序。对于某些提示，可以指定默认区域设置。 

### <a name="prompt-locale"></a>提示区域设置

使用区域设置来确定**选项**、**确认**、**日期时间**和**数字**提示的特定于语言的行为。 对于用户提供的任何给定输入，如果通道在用户的消息中提供了 _locale_ 属性，则使用该属性。 否则，如果设置了提示的默认区域设置（通过在调用提示的构造函数时提供，或者在以后进行设置），则会使用该区域设置。 如果未提供上述任一属性，则使用“英语”("en-us") 作为区域设置。 注意：区域设置是由 2、3 或 4 个字符组成的 ISO 639 代码，代表某种语言或语言系列。

## <a name="dialog-state"></a>对话框状态

对话是实现多轮次聊天的一种方法，因此，在依赖于跨多个轮次的持久化状态的 SDK 中，对话可以充当特征的示例。 如果对话中没有状态，则机器人就不知道它在对话集中所处的位置，也不知道它已收集的信息。

通常，基于对话的机器人在其机器人实现中以成员变量的形式保存对话集集合。 该对话集是使用称作“访问器”（可用于访问持久性状态）的对象句柄创建的。 有关机器人中的状态的背景信息，请参阅[管理状态](bot-builder-concept-state.md)。 

![对话框状态](media/bot-builder-dialog-state.png)

调用机器人的轮次处理程序时，机器人会通过针对对话集调用 *create context*（这会返回对话上下文）来初始化对话子系统。 创建对话上下文需要状态，可以使用创建对话集时提供的访问器来访问状态。 对话集可以使用访问器获得相应的对话状态 JSON。 该对话上下文包含对话所需的信息。

在[保存聊天和用户数据](bot-builder-howto-v4-state.md)中可以找到有关状态访问器的详细信息。

## <a name="repeating-a-dialog"></a>重复某个对话框

若要重复某个对话框，请使用 *replace dialog* 方法。 对话框上下文的 *replace dialog* 方法会将当前对话框从堆栈中弹出，并将用于替换的对话框推送到堆栈顶层，然后启动该对话框。 可以使用此方法并将某个对话替换为其自身，来创建循环。 请注意，如需暂存当前对话框的内部状态，则需在调用 _replace dialog_ 方法时将信息传递给对话框的新实例，然后适当地初始化对话框。 传递到新对话框中的选项可以在对话框的任何步骤中通过步骤上下文的 _options_ 属性进行访问。 这是处理复杂聊天流或管理菜单的极佳方法。

## <a name="branch-a-conversation"></a>将聊天分支

对话上下文维护对话堆栈，对于堆栈中的每个对话，将跟踪下一个步骤是什么。 它的 _begin dialog_ 方法将对话框推送到堆栈的顶层，_end dialog_ 方法从堆栈中弹出顶层对话框。

一个对话框可以调用对话框上下文的 _begin dialog_ 方法并提供新对话框的 ID，以便启动同一对话框集中的新对话框，随后使新对话框成为当前的活动对话框。 原始对话框仍保留在堆栈中，但对对话框上下文的 _continue dialog_ 方法的调用只会发送到位于堆栈顶层的对话框，即“活动对话框”。 将某个对话框从堆栈中弹出后，对话框上下文会在堆栈中弹出原始对话框的位置处继续执行瀑布框的下一步。

因此，可以在聊天流中创建分支，方法是在一个对话框中包含一个选择步骤（该步骤可按条件从一组可用对话框中选出一个要启动的对话框）。

## <a name="component-dialog"></a>组件对话框
有时需编写一个可重用的对话框，在不同的场景中使用。 例如，编写一个地址对话框，要求用户提供邮政编码、城市和街道的值。 

ComponentDialog 可以进行某种程度的隔离，因为它有单独的 DialogSet。 有单独的 DialogSet 意味着，它可以避免与包含对话框的父项发生名称冲突，可以通过创建自己的 DialogContext 来创建自己的独立的内部对话框运行时，还可以将活动调度到该运行时。 这个辅助调度意味着，它有机会截获活动。 这特别适用于需要实现“帮助”和“取消”之类功能的情况。  参阅[企业机器人模板](https://aka.ms/abs/templates/cabot)示例。 

## <a name="next-steps"></a>后续步骤

> [!div class="nextstepaction"]
> [使用对话库收集用户输入](bot-builder-prompts.md)
